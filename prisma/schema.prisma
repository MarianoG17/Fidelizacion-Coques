// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

// ─── Enums ─────────────────────────────────────────────────────────────────────

enum EstadoCliente {
  ACTIVO
  PRE_REGISTRADO
  INACTIVO
}

enum FuenteOrigen {
  AIRES
  LAVADERO
  AUTOREGISTRO
  MANUAL
}

enum TipoEvento {
  VISITA
  BENEFICIO_APLICADO
  ESTADO_EXTERNO
  ACTIVACION
  ASISTENCIA_EVENTO
}

enum MetodoValidacion {
  QR
  OTP_MANUAL
}

enum EstadoAutoEnum {
  EN_PROCESO
  LISTO
  ENTREGADO
}

enum EstadoEventoEspecial {
  BORRADOR
  PUBLICADO
  CANCELADO
  FINALIZADO
}

enum EstadoInscripcion {
  CONFIRMADA
  CANCELADA_SIN_PENALIDAD
  CANCELADA_CON_PENALIDAD
  ASISTIO
  NO_ASISTIO
}

enum TipoNoticia {
  INFO
  BENEFICIO
  NIVEL
  EVENTO
  ADVERTENCIA
}

// ─── Modelos ───────────────────────────────────────────────────────────────────

model Cliente {
  id                    String        @id @default(uuid())
  phone                 String        @unique   // E.164: +5491112345678
  nombre                String?
  email                 String?       @unique
  password              String?       // bcrypt hasheado
  estado                EstadoCliente @default(PRE_REGISTRADO)
  nivelId               String?
  nivel                 Nivel?        @relation(fields: [nivelId], references: [id])
  fuenteOrigen          FuenteOrigen  @default(AUTOREGISTRO)
  consentimientoAt      DateTime?
  otpSecret             String?       // TOTP secret encriptado, se asigna al activar
  pushSub               Json?         // Web Push subscription object
  fechaCumpleanos       DateTime?     // fecha de cumpleaños para descuentos especiales
  fuenteConocimiento    String?       // cómo conoció el negocio: Amigos, Instagram, Google Maps, Vi luz y entré
  codigoReferido        String?       @unique  // código único para compartir con amigos
  referidoPorId         String?       // ID del cliente que lo refirió
  referidoPor           Cliente?      @relation("Referidos", fields: [referidoPorId], references: [id])
  referidos             Cliente[]     @relation("Referidos")
  referidosActivados    Int           @default(0)  // contador de referidos que se activaron
  resetPasswordToken    String?       @unique  // token para recuperación de contraseña
  resetPasswordExpires  DateTime?     // expiración del token
  eventos               EventoScan[]
  autos                 Auto[]        // un cliente puede tener múltiples autos
  inscripciones         Inscripcion[]
  noticias              Noticia[]
  feedbacks             Feedback[]
  logros                LogroCliente[]
  sesionesMesa          SesionMesa[]  // sesiones en mesas del salón
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  @@index([phone])
  @@index([nivelId])
  @@index([codigoReferido])
  @@index([resetPasswordToken])
}

model Local {
  id          String       @id @default(uuid())
  nombre      String
  tipo        String       // "cafeteria" | "lavadero" | "otro"
  apiKey      String       @unique  // para autenticar requests del dispositivo del local
  layoutMesas Json?        // JSON con coordenadas del mapa visual
  activo      Boolean      @default(true)
  eventos     EventoScan[]
  mesas       Mesa[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Mesa {
  id          String        @id @default(uuid())
  localId     String
  local       Local         @relation(fields: [localId], references: [id])
  nombre      String        // "1", "2", "Barra", "Terraza 3"
  posX        Float         // coordenada X en el layout visual (%)
  posY        Float         // coordenada Y en el layout visual (%)
  ancho       Float         // ancho en el layout (%)
  alto        Float         // alto en el layout (%)
  activa      Boolean       @default(true)
  eventos     EventoScan[]
  sesiones    SesionMesa[]  // sesiones activas de esta mesa

  @@index([localId])
}

// Sesión activa de un cliente en una mesa
model SesionMesa {
  id              String    @id @default(uuid())
  clienteId       String
  cliente         Cliente   @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  mesaId          String
  mesa            Mesa      @relation(fields: [mesaId], references: [id], onDelete: Cascade)
  localId         String
  inicioSesion    DateTime  @default(now())
  finSesion       DateTime? // null mientras está activa
  activa          Boolean   @default(true)
  cerradaPor      String?   // "STAFF" | "TIMEOUT" | "CLIENTE"
  duracionMinutos Int?      // calculado al cerrar

  @@index([mesaId])
  @@index([clienteId])
  @@index([activa])
  @@index([localId, activa])  // para consultas rápidas del estado del salón
}

model Nivel {
  id         String           @id @default(uuid())
  nombre     String           @unique  // "Bronce" | "Plata" | "Oro" | "Platino"
  orden      Int              @unique  // 1, 2, 3, 4 — para comparar
  criterios  Json
  // criterios: { visitas: 6, diasVentana: 30, usosCruzados: 0, visitasTotal: 0 }
  descripcionBeneficios String?  // Descripción de los beneficios del nivel
  clientes         Cliente[]
  beneficios       NivelBeneficio[]
  eventosEspeciales EventoEspecial[]
  logros           Logro[]
  createdAt        DateTime         @default(now())
}

model Beneficio {
  id                    String           @id @default(uuid())
  nombre                String
  descripcionCaja       String           // texto exacto para cargar en Aires
  condiciones           Json
  // condiciones: { maxPorDia: 1, maxPorMes: 3, duracionMinutos: 120 }
  requiereEstadoExterno Boolean          @default(false)
  estadoExternoTrigger  String?          // "EN_LAVADO" | "EN_SECADO"
  localDestinoId        String?          // null = todos los locales
  activo                Boolean          @default(true)
  niveles               NivelBeneficio[]
  eventos               EventoScan[]
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
}

model NivelBeneficio {
  nivelId     String
  beneficioId String
  nivel       Nivel     @relation(fields: [nivelId], references: [id])
  beneficio   Beneficio @relation(fields: [beneficioId], references: [id])

  @@id([nivelId, beneficioId])
}

model EventoScan {
  id                 String           @id @default(uuid())
  clienteId          String
  cliente            Cliente          @relation(fields: [clienteId], references: [id])
  localId            String
  local              Local            @relation(fields: [localId], references: [id])
  mesaId             String?
  mesa               Mesa?            @relation(fields: [mesaId], references: [id])
  timestamp          DateTime         @default(now())   // server-side, TZ fija
  tipoEvento         TipoEvento
  beneficioId        String?
  beneficio          Beneficio?       @relation(fields: [beneficioId], references: [id])
  metodoValidacion   MetodoValidacion
  estadoExternoSnap  Json?            // snapshot del EstadoAuto al momento del scan
  notas              String?
  // false si supera el límite de 1 visita/día — se registra pero no cuenta para niveles
  contabilizada      Boolean          @default(true)

  @@index([clienteId])
  @@index([localId])
  @@index([timestamp])
  @@index([clienteId, timestamp])       // para consultas de frecuencia/niveles
  @@index([clienteId, contabilizada])   // para contar visitas reales
}

model EventoEspecial {
  id               String               @id @default(uuid())
  titulo           String
  descripcion      String               // detalle del evento (markdown soportado)
  fechaEvento      DateTime
  lugarDetalle     String?              // "Salón principal de Coques"
  nivelMinimoId    String               // nivel mínimo para inscribirse
  nivelMinimo      Nivel                @relation(fields: [nivelMinimoId], references: [id])
  cupoMaximo       Int
  inscriptosCount  Int                  @default(0)  // contador para control de concurrencia
  estado           EstadoEventoEspecial @default(BORRADOR)
  imagenUrl        String?
  inscripciones    Inscripcion[]
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  @@index([fechaEvento])
  @@index([estado])
}

model Inscripcion {
  id                String            @id @default(uuid())
  clienteId         String
  cliente           Cliente           @relation(fields: [clienteId], references: [id])
  eventoId          String
  evento            EventoEspecial    @relation(fields: [eventoId], references: [id])
  estado            EstadoInscripcion @default(CONFIRMADA)
  penalizadoAt      DateTime?         // cuando se aplicó la penalidad
  visitasDescontadas Int              @default(0)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@unique([clienteId, eventoId])     // un cliente solo se inscribe una vez por evento
  @@index([eventoId])
  @@index([clienteId])
}

model Noticia {
  id         String      @id @default(uuid())
  clienteId  String
  cliente    Cliente     @relation(fields: [clienteId], references: [id])
  titulo     String
  cuerpo     String?
  tipo       TipoNoticia @default(INFO)
  leida      Boolean     @default(false)
  accionUrl  String?     // link opcional dentro de la app
  createdAt  DateTime    @default(now())

  @@index([clienteId, leida])
  @@index([clienteId, createdAt])
}

// Modelo Auto — permite múltiples autos por cliente
model Auto {
  id            String         @id @default(uuid())
  clienteId     String
  cliente       Cliente        @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  patente       String         // patente normalizada (ABC123)
  marca         String?        // ej: Toyota, Ford
  modelo        String?        // ej: Corolla, Fiesta
  alias         String?        // nombre que le pone el cliente: "Auto de trabajo"
  activo        Boolean        @default(true)
  estadoActual  EstadoAuto?    // relación 1:1 con el estado actual
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@unique([clienteId, patente])  // un cliente no puede tener dos autos con la misma patente
  @@index([clienteId])
  @@index([patente])
}

// Estado actual del auto en el lavadero
model EstadoAuto {
  id            String         @id @default(uuid())
  autoId        String         @unique
  auto          Auto           @relation(fields: [autoId], references: [id], onDelete: Cascade)
  estado        EstadoAutoEnum
  localOrigenId String
  notas         String?
  updatedAt     DateTime       @updatedAt
  createdAt     DateTime       @default(now())

  @@index([autoId])
  @@index([estado])
}

// Sistema de Feedback y Calificaciones
model Feedback {
  id                String   @id @default(uuid())
  clienteId         String
  cliente           Cliente  @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  localId           String
  eventoScanId      String?  // puede estar vinculado a una visita específica
  calificacion      Int      // 1-5 estrellas
  comentario        String?
  enviadoGoogleMaps Boolean  @default(false)  // si se redirigió a Google Maps
  createdAt         DateTime @default(now())

  @@index([clienteId])
  @@index([localId])
  @@index([calificacion])
  @@index([createdAt])
}

// Sistema de Gamificación - Logros/Badges
enum TipoLogro {
  PRIMERA_VISITA
  VISITAS_CONSECUTIVAS
  NIVEL_ALCANZADO
  REFERIDOS
  FEEDBACK_POSITIVO
  CUMPLEANOS
  ANIVERSARIO
  USO_CRUZADO
  MADRUGADOR
  CLIENTE_VIP
}

model Logro {
  id           String          @id @default(uuid())
  nombre       String
  descripcion  String
  tipo         TipoLogro
  icono        String?         // emoji o URL de imagen
  nivelId      String?         // logro específico de un nivel
  nivel        Nivel?          @relation(fields: [nivelId], references: [id])
  criterios    Json            // condiciones para obtener el logro
  // criterios: { visitasConsecutivas: 5, diasVentana: 7 }
  puntosXp     Int             @default(0)  // puntos de experiencia que otorga
  activo       Boolean         @default(true)
  clientes     LogroCliente[]
  createdAt    DateTime        @default(now())

  @@index([tipo])
  @@index([nivelId])
}

model LogroCliente {
  id         String   @id @default(uuid())
  clienteId  String
  cliente    Cliente  @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  logroId    String
  logro      Logro    @relation(fields: [logroId], references: [id])
  obtenidoEn DateTime @default(now())
  visto      Boolean  @default(false)  // para mostrar notificación de "nuevo logro"

  @@unique([clienteId, logroId])  // un cliente solo puede obtener un logro una vez
  @@index([clienteId])
  @@index([logroId])
  @@index([obtenidoEn])
}
